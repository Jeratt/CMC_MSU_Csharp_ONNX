# CMC_MSU_Csharp_ONNX
Георгий Сазонов - лабораторные работы

# Задание 1

## Вариант 2. 

Требуется разработать компонент для обнаружения объектов на изображении с применением готовой нейронной сети в формате ONNX. Нейронная сеть: https://storage.yandexcloud.net/dotnet4/tinyyolov2-8.onnx. Описание нейронной сети: https://github.com/onnx/models/tree/main/vision/object_detection_segmentation/tiny-yolov2. 

Компонент принимает на вход изображение. Выходом являются изображения найденных объектов с указанием класса объекта и расположения объекта на исходном изображении. Результаты должны возвращаться по мере их получения. 

Результатом выполнения задания 2 является консольная программа, принимающая в качестве аргумента командной строки имя файла с изображением. Программа записывает в отдельные файлы изображения всех найденных объектов и формирует файл в формате CSV со следующими столбцами: filename, class, x, y, w, h где: 
* filename - имя файла с объектом 
* сlass - тип объекта 
* x,y,w,h - верхний левый угол и размеры ограничивающего объект прямоугольника на исходном изображении.   

Можно взять за основу пример: https://github.com/sergey-berezin/dotnet4/tree/master/onnx/YOLO 

## Общие требования 
Компонент размещен в отдельном пакете NuGet и должен быть переиспользован в последующих заданиях без перекомпиляции. Компонент должен быть максимально независим от среды использования, в частности не использовать консольный ввод/вывод и не работать напрямую с файловой системой.  
Пример  создания пакета NuGet: https://github.com/sergey-berezin/dotnet4/tree/master/nuget 
Документация по создания пакетов NuGet (Visual Studio Code): https://learn.microsoft.com/en-us/nuget/create-packages/creating-a-package-dotnet-cli 

В целях экономии памяти компонент должен создавать только один экземпляр модели (сессии), но предоставлять асинхронный потокобезопасный API с возможностью отмены вычисления при помощи CancellationToken. 
* Пример линеаризации доступа с применением mailbox: https://github.com/sergey-berezin/dotnet4/tree/master/1.%20Concurrency/mailboxasync 
* Пример линеаризация доступа с применением TPL DataFlow: https://github.com/sergey-berezin/dotnet4/tree/master/1.%20Concurrency/mailboxtplflow 
* Можно использовать оператор lock, но обязательно в отдельном ПОТОКЕ, не ЗАДАЧЕ! 
* Пример использования Cancellation Token см. в этом примере: https://github.com/sergey-berezin/dotnet4/blob/master/1.%20Concurrency/mailboxasync/Program.cs 

Компонент должен скачивать нейронную сеть в формате ONNX на диск при первом обращении.  
* При последующих обращениях используется существующий файл. 
* Временные ошибки при скачивании должны обрабатываться методом повтора.

# Задание 2
Требуется разработать приложение с графическим пользовательским интерфейсом для поиска объектов на изображениях. 

## Вариант (а):
Приложение предоставляет пользователю возможность указать каталог с изображениями в формате .JPG. Для выбора каталога из приложения WPF можно использовать https://www.ookii.org/software/dialogs/. Главное окно приложения разбито на две части. В одной части находится список уменьшенных изображений всех найденных объектов с текстовым указанием имени класса и степени уверенности. Изображения упорядочены по имени класса, затем по степени уверенности. При выборе объекта во второй части окна появляется исходное изображения с ограничивающим прямоугольником вокруг выбранного объекта. 

## Общие требования 
* Обработка изображений или текста выполняется  c применением пакета NuGet, разработанного при выполнении Задания 1. Проект с Заданием 1 должен остаться работоспособным! 
* Пользовательский интерфейс не должен "зависать" в процессе работы, включая загрузку модели. 
* Пользователь имеет возможность прерывать процесс анализа изображения или ответа на вопрос нажатием на экранную кнопку.  
* Приложение не должно "падать" с исключениями при любых действиях пользователя. 

## Дополнительные материалы 
* Сортировка списков в WPF: https://github.com/sergey-berezin/dotnet4/tree/master/SortedCollection 
* Асинхронные команды в WPF: https://github.com/sergey-berezin/dotnet4/tree/master/AsyncCommand

# Задание 3

Требуется расширить функциональность приложения из задания 2 возможностью хранения и использования результатов работы в предыдущих запусках. 
Приложение хранит все изображения и результаты их обработки. При повторном запуске информация о всех ранее обработанных изображениях отображается в пользовательском интерфейсе. При обработке очередного файла приложение проверяет не был ли такой файл ранее обработан и не выполняет повторную обработку и добавление в хранилище, если файл был обработан. 
Во всех вариантах приложение позволяет очистить хранилище результатов. 
Выбор способа хранения осуществляется в зависимости от варианта. 

## Вариант (б)
* Постоянное хранилище представляет собой файл формата JSON. 
* Содержимое изображений (вариант 2) хранится в файле в виде строк формата Base64.  Для поиска дубликатов изображений используется побайтовое сравнение. 
* Обновление JSON-файла организовано так, чтобы избежать потерю данных при внезапном сбое.
  
# Задание 4
Требуется разработать веб-приложение для обнаружения объектов на изображении. Приложение состоит из HTTP-сервиса (серверная часть) и страницы HTML5 (клиентская часть). Серверная часть приложение использует компонент из первого задания для ответа на вопросы с применением нейронной сети. 

## Вариант (а)
Серверная часть поддерживает запрос POST для анализа изображения. Изображение передаётся в теле запроса. Ответом является документ в формате JSON, в котором перечислены координаты прямоугольников обнаруженных объектов, наиболее вероятный класс объекта и степень уверенности. 

Пользовательский интерфейс предоставляет кнопку для выбора файла с изображением на локальном диске и отправки изображения на сервер. После выбора файла изображение отображается на странице.  

После получения ответа от сервера, на изображении появляются ограничивающие прямоугольники, а на странице появляется список объектов с указанием наиболее вероятного класса и степени уверенности. При выборе элемента из списка, соответствующий ограничивающий прямоугольник подсвечивается. 

## Общие требования 

В решение должны быть включены сценарные тесты для серверной части. Cценарные тесты описаны здесь: https://timdeschryver.dev/blog/how-to-test-your-csharp-web-api#a-simple-test-using-xunit-and-39-s-fixtures 
